// Package main (fauxmailer) generates fake emails and sends them via SMTP.
package main // import "github.com/inbucket/fauxmailer"

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"log"
	"math/rand"
	"os"
	"strings"
	"time"

	"github.com/jhillyerd/enmime"
	"github.com/manveru/faker"
)

var (
	// Flags.
	delay     = flag.Duration("every", 0, "sends a message every <duration> if non-zero")
	host      = flag.String("host", "localhost:25", "host:port of SMTP server")
	signature = flag.String(
		"signature",
		"Generated by https://github.com/inbucket/fauxmailer",
		"signature")
	silent  = flag.Bool("silent", false, "disable to/from address log")
	tofile  = flag.String("tofile", "", "optional file containing newline separated To addresses")
	verbose = flag.Bool("verbose", false, "enable verbose output")

	random  = rand.New(rand.NewSource(time.Now().UnixNano()))
	toaddrs []string
)

func main() {
	flag.Parse()
	fake, err := faker.New("en")
	if err != nil {
		log.Fatal(err)
	}

	// Load To address set if specified.
	if *tofile != "" {
		err = loadToAddresses()
		if err != nil {
			log.Fatal(err)
		}
	}

	sender := enmime.NewSMTP(*host, nil)
	buf := &bytes.Buffer{}
	for {
		msg := generateMessage(fake)
		if *verbose {
			buf.Reset()
			part, err := msg.Build()
			if err != nil {
				log.Fatal(err)
			}
			err = part.Encode(buf)
			if err != nil {
				log.Fatal(err)
			}
			log.Printf("Sending:\n%s", buf.String())
		}

		if err = msg.Send(sender); err != nil {
			log.Fatal(err)
		}

		// Loop if delay was specified.
		if *delay > 0 {
			time.Sleep(*delay)
		} else {
			return
		}
	}
}

// generateMessage uses faker to create a random message struct.
func generateMessage(fake *faker.Faker) enmime.MailBuilder {
	// Use provided To address if available.
	var to string
	if toaddrs != nil {
		to = toaddrs[random.Intn(len(toaddrs))]
	} else {
		to = fake.Email()
	}
	from := fake.Email()
	company := fake.CompanyName()

	// Plain text.
	cosig := fmt.Sprintf("%s <%s>, %s\r\n%s, \"%s\"",
		fake.Name(),
		from,
		fake.JobTitle(),
		company,
		fake.CompanyCatchPhrase())
	paragraphs := fake.Paragraphs(4, true)
	textp := append(make([]string, 0), paragraphs...)
	textp = append(textp, cosig)
	if *signature != "" {
		textp = append(textp, "--\r\n"+*signature)
	}

	// HTML.
	cosig = fmt.Sprintf("%s &lt;<a href=\"mailto:%s\">%s</a>&gt;, %s<br>\r\n<b>%s</b>, <em>%s</em>",
		fake.Name(),
		from,
		from,
		fake.JobTitle(),
		company,
		fake.CompanyCatchPhrase())
	htmlp := append(make([]string, 0), paragraphs...)
	htmlp = append(htmlp, cosig)

	if *signature != "" {
		htmlp = append(htmlp, "<small>"+*signature+"</small>")
	}

	if !*silent {
		log.Println(from, "->", to)
	}

	return enmime.Builder().
		From("", from).
		To("", to).
		Subject(strings.Title(fake.CompanyBs()) + " with " + company).
		Text([]byte(strings.Join(textp, "\r\n\r\n"))).
		HTML([]byte("<p>" + strings.Join(htmlp, "</p>\r\n<p>") + "</p>"))
}

// loadToAddresses from specified file, one per line.
func loadToAddresses() error {
	f, err := os.Open(*tofile)
	if err != nil {
		return err
	}

	toaddrs = make([]string, 0)
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		addr := strings.TrimSpace(scanner.Text())
		if addr != "" {
			toaddrs = append(toaddrs, addr)
			if *verbose {
				log.Printf("Added To address: %s", addr)
			}
		}
	}

	return scanner.Err()
}
